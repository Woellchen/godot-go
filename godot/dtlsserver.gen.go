package godot

import (
	"github.com/Woellchen/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//func NewDTLSServerFromPointer(ptr gdnative.Pointer) DTLSServer {
func newDTLSServerFromPointer(ptr gdnative.Pointer) DTLSServer {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := DTLSServer{}
	obj.SetBaseObject(owner)

	return obj
}

/*
This class is used to store the state of a DTLS server. Upon [method setup] it converts connected [PacketPeerUDP] to [PacketPeerDTLS] accepting them via [method take_connection] as DTLS clients. Under the hood, this class is used to store the DTLS state and cookies of the server. The reason of why the state and cookies are needed is outside of the scope of this documentation. Below a small example of how to use it: [codeblock] # server.gd extends Node var dtls := DTLSServer.new() var server := UDPServer.new() var peers = [] func _ready(): server.listen(4242) var key = load("key.key") # Your private key. var cert = load("cert.crt") # Your X509 certificate. dtls.setup(key, cert) func _process(delta): while server.is_connection_available(): var peer : PacketPeerUDP = server.take_connection() var dtls_peer : PacketPeerDTLS = dtls.take_connection(peer) if dtls_peer.get_status() != PacketPeerDTLS.STATUS_HANDSHAKING: continue # It is normal that 50% of the connections fails due to cookie exchange. print("Peer connected!") peers.append(dtls_peer) for p in peers: p.poll() # Must poll to update the state. if p.get_status() == PacketPeerDTLS.STATUS_CONNECTED: while p.get_available_packet_count() > 0: print("Received message from client: %s" % p.get_packet().get_string_from_utf8()) p.put_packet("Hello DTLS client".to_utf8()) [/codeblock] [codeblock] # client.gd extends Node var dtls := PacketPeerDTLS.new() var udp := PacketPeerUDP.new() var connected = false func _ready(): udp.connect_to_host("127.0.0.1", 4242) dtls.connect_to_peer(udp, false) # Use true in production for certificate validation! func _process(delta): dtls.poll() if dtls.get_status() == PacketPeerDTLS.STATUS_CONNECTED: if !connected: # Try to contact server dtls.put_packet("The answer is... 42!".to_utf8()) while dtls.get_available_packet_count() > 0: print("Connected: %s" % dtls.get_packet().get_string_from_utf8()) connected = true [/codeblock]
*/
type DTLSServer struct {
	Reference
	owner gdnative.Object
}

func (o *DTLSServer) BaseClass() string {
	return "DTLSServer"
}

/*
        Setup the DTLS server to use the given [code]private_key[/code] and provide the given [code]certificate[/code] to clients. You can pass the optional [code]chain[/code] parameter to provide additional CA chain information along with the certificate.
	Args: [{ false key CryptoKey} { false certificate X509Certificate} {[Object:null] true chain X509Certificate}], Returns: enum.Error
*/
func (o *DTLSServer) Setup(key CryptoKeyImplementer, certificate X509CertificateImplementer, chain X509CertificateImplementer) gdnative.Error {
	// log.Println("Calling DTLSServer.Setup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromObject(key.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromObject(certificate.GetBaseObject())
	ptrArguments[2] = gdnative.NewPointerFromObject(chain.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("DTLSServer", "setup")

	// Call the parent method.
	// enum.Error
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return gdnative.Error(ret)
}

/*
        Try to initiate the DTLS handshake with the given [code]udp_peer[/code] which must be already connected (see [method PacketPeerUDP.connect_to_host]). [b]Note[/b]: You must check that the state of the return PacketPeerUDP is [constant PacketPeerDTLS.STATUS_HANDSHAKING], as it is normal that 50% of the new connections will be invalid due to cookie exchange.
	Args: [{ false udp_peer PacketPeerUDP}], Returns: PacketPeerDTLS
*/
func (o *DTLSServer) TakeConnection(udpPeer PacketPeerUDPImplementer) PacketPeerDTLSImplementer {
	// log.Println("Calling DTLSServer.TakeConnection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(udpPeer.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("DTLSServer", "take_connection")

	// Call the parent method.
	// PacketPeerDTLS
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newPacketPeerDTLSFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(PacketPeerDTLSImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "PacketPeerDTLS" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(PacketPeerDTLSImplementer)
	}

	return &ret
}

// DTLSServerImplementer is an interface that implements the methods
// of the DTLSServer class.
type DTLSServerImplementer interface {
	ReferenceImplementer
	TakeConnection(udpPeer PacketPeerUDPImplementer) PacketPeerDTLSImplementer
}
